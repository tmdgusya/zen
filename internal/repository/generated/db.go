// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package repository

import (
	"context"
	"database/sql"
	"fmt"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

func Prepare(ctx context.Context, db DBTX) (*Queries, error) {
	q := Queries{db: db}
	var err error
	if q.acquireDistributedLockStmt, err = db.PrepareContext(ctx, AcquireDistributedLock); err != nil {
		return nil, fmt.Errorf("error preparing query AcquireDistributedLock: %w", err)
	}
	if q.cleanupExpiredLocksStmt, err = db.PrepareContext(ctx, CleanupExpiredLocks); err != nil {
		return nil, fmt.Errorf("error preparing query CleanupExpiredLocks: %w", err)
	}
	if q.cleanupOldExecutionsStmt, err = db.PrepareContext(ctx, CleanupOldExecutions); err != nil {
		return nil, fmt.Errorf("error preparing query CleanupOldExecutions: %w", err)
	}
	if q.createJobStmt, err = db.PrepareContext(ctx, CreateJob); err != nil {
		return nil, fmt.Errorf("error preparing query CreateJob: %w", err)
	}
	if q.createJobExecutionStmt, err = db.PrepareContext(ctx, CreateJobExecution); err != nil {
		return nil, fmt.Errorf("error preparing query CreateJobExecution: %w", err)
	}
	if q.deleteJobStmt, err = db.PrepareContext(ctx, DeleteJob); err != nil {
		return nil, fmt.Errorf("error preparing query DeleteJob: %w", err)
	}
	if q.deleteSchedulerStateStmt, err = db.PrepareContext(ctx, DeleteSchedulerState); err != nil {
		return nil, fmt.Errorf("error preparing query DeleteSchedulerState: %w", err)
	}
	if q.getDistributedLockStmt, err = db.PrepareContext(ctx, GetDistributedLock); err != nil {
		return nil, fmt.Errorf("error preparing query GetDistributedLock: %w", err)
	}
	if q.getJobStmt, err = db.PrepareContext(ctx, GetJob); err != nil {
		return nil, fmt.Errorf("error preparing query GetJob: %w", err)
	}
	if q.getJobByNameStmt, err = db.PrepareContext(ctx, GetJobByName); err != nil {
		return nil, fmt.Errorf("error preparing query GetJobByName: %w", err)
	}
	if q.getJobExecutionStmt, err = db.PrepareContext(ctx, GetJobExecution); err != nil {
		return nil, fmt.Errorf("error preparing query GetJobExecution: %w", err)
	}
	if q.getJobExecutionStatsStmt, err = db.PrepareContext(ctx, GetJobExecutionStats); err != nil {
		return nil, fmt.Errorf("error preparing query GetJobExecutionStats: %w", err)
	}
	if q.getJobsReadyToRunStmt, err = db.PrepareContext(ctx, GetJobsReadyToRun); err != nil {
		return nil, fmt.Errorf("error preparing query GetJobsReadyToRun: %w", err)
	}
	if q.getRunningExecutionsStmt, err = db.PrepareContext(ctx, GetRunningExecutions); err != nil {
		return nil, fmt.Errorf("error preparing query GetRunningExecutions: %w", err)
	}
	if q.getSchedulerStateStmt, err = db.PrepareContext(ctx, GetSchedulerState); err != nil {
		return nil, fmt.Errorf("error preparing query GetSchedulerState: %w", err)
	}
	if q.getSystemStatsStmt, err = db.PrepareContext(ctx, GetSystemStats); err != nil {
		return nil, fmt.Errorf("error preparing query GetSystemStats: %w", err)
	}
	if q.listActiveJobsStmt, err = db.PrepareContext(ctx, ListActiveJobs); err != nil {
		return nil, fmt.Errorf("error preparing query ListActiveJobs: %w", err)
	}
	if q.listJobExecutionsStmt, err = db.PrepareContext(ctx, ListJobExecutions); err != nil {
		return nil, fmt.Errorf("error preparing query ListJobExecutions: %w", err)
	}
	if q.listJobsStmt, err = db.PrepareContext(ctx, ListJobs); err != nil {
		return nil, fmt.Errorf("error preparing query ListJobs: %w", err)
	}
	if q.listRecentJobExecutionsStmt, err = db.PrepareContext(ctx, ListRecentJobExecutions); err != nil {
		return nil, fmt.Errorf("error preparing query ListRecentJobExecutions: %w", err)
	}
	if q.listSchedulerStatesStmt, err = db.PrepareContext(ctx, ListSchedulerStates); err != nil {
		return nil, fmt.Errorf("error preparing query ListSchedulerStates: %w", err)
	}
	if q.releaseDistributedLockStmt, err = db.PrepareContext(ctx, ReleaseDistributedLock); err != nil {
		return nil, fmt.Errorf("error preparing query ReleaseDistributedLock: %w", err)
	}
	if q.renewDistributedLockStmt, err = db.PrepareContext(ctx, RenewDistributedLock); err != nil {
		return nil, fmt.Errorf("error preparing query RenewDistributedLock: %w", err)
	}
	if q.updateJobStmt, err = db.PrepareContext(ctx, UpdateJob); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateJob: %w", err)
	}
	if q.updateJobExecutionStmt, err = db.PrepareContext(ctx, UpdateJobExecution); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateJobExecution: %w", err)
	}
	if q.updateJobStatusStmt, err = db.PrepareContext(ctx, UpdateJobStatus); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateJobStatus: %w", err)
	}
	if q.upsertSchedulerStateStmt, err = db.PrepareContext(ctx, UpsertSchedulerState); err != nil {
		return nil, fmt.Errorf("error preparing query UpsertSchedulerState: %w", err)
	}
	return &q, nil
}

func (q *Queries) Close() error {
	var err error
	if q.acquireDistributedLockStmt != nil {
		if cerr := q.acquireDistributedLockStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing acquireDistributedLockStmt: %w", cerr)
		}
	}
	if q.cleanupExpiredLocksStmt != nil {
		if cerr := q.cleanupExpiredLocksStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing cleanupExpiredLocksStmt: %w", cerr)
		}
	}
	if q.cleanupOldExecutionsStmt != nil {
		if cerr := q.cleanupOldExecutionsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing cleanupOldExecutionsStmt: %w", cerr)
		}
	}
	if q.createJobStmt != nil {
		if cerr := q.createJobStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createJobStmt: %w", cerr)
		}
	}
	if q.createJobExecutionStmt != nil {
		if cerr := q.createJobExecutionStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createJobExecutionStmt: %w", cerr)
		}
	}
	if q.deleteJobStmt != nil {
		if cerr := q.deleteJobStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing deleteJobStmt: %w", cerr)
		}
	}
	if q.deleteSchedulerStateStmt != nil {
		if cerr := q.deleteSchedulerStateStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing deleteSchedulerStateStmt: %w", cerr)
		}
	}
	if q.getDistributedLockStmt != nil {
		if cerr := q.getDistributedLockStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getDistributedLockStmt: %w", cerr)
		}
	}
	if q.getJobStmt != nil {
		if cerr := q.getJobStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getJobStmt: %w", cerr)
		}
	}
	if q.getJobByNameStmt != nil {
		if cerr := q.getJobByNameStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getJobByNameStmt: %w", cerr)
		}
	}
	if q.getJobExecutionStmt != nil {
		if cerr := q.getJobExecutionStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getJobExecutionStmt: %w", cerr)
		}
	}
	if q.getJobExecutionStatsStmt != nil {
		if cerr := q.getJobExecutionStatsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getJobExecutionStatsStmt: %w", cerr)
		}
	}
	if q.getJobsReadyToRunStmt != nil {
		if cerr := q.getJobsReadyToRunStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getJobsReadyToRunStmt: %w", cerr)
		}
	}
	if q.getRunningExecutionsStmt != nil {
		if cerr := q.getRunningExecutionsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getRunningExecutionsStmt: %w", cerr)
		}
	}
	if q.getSchedulerStateStmt != nil {
		if cerr := q.getSchedulerStateStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getSchedulerStateStmt: %w", cerr)
		}
	}
	if q.getSystemStatsStmt != nil {
		if cerr := q.getSystemStatsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getSystemStatsStmt: %w", cerr)
		}
	}
	if q.listActiveJobsStmt != nil {
		if cerr := q.listActiveJobsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing listActiveJobsStmt: %w", cerr)
		}
	}
	if q.listJobExecutionsStmt != nil {
		if cerr := q.listJobExecutionsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing listJobExecutionsStmt: %w", cerr)
		}
	}
	if q.listJobsStmt != nil {
		if cerr := q.listJobsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing listJobsStmt: %w", cerr)
		}
	}
	if q.listRecentJobExecutionsStmt != nil {
		if cerr := q.listRecentJobExecutionsStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing listRecentJobExecutionsStmt: %w", cerr)
		}
	}
	if q.listSchedulerStatesStmt != nil {
		if cerr := q.listSchedulerStatesStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing listSchedulerStatesStmt: %w", cerr)
		}
	}
	if q.releaseDistributedLockStmt != nil {
		if cerr := q.releaseDistributedLockStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing releaseDistributedLockStmt: %w", cerr)
		}
	}
	if q.renewDistributedLockStmt != nil {
		if cerr := q.renewDistributedLockStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing renewDistributedLockStmt: %w", cerr)
		}
	}
	if q.updateJobStmt != nil {
		if cerr := q.updateJobStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateJobStmt: %w", cerr)
		}
	}
	if q.updateJobExecutionStmt != nil {
		if cerr := q.updateJobExecutionStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateJobExecutionStmt: %w", cerr)
		}
	}
	if q.updateJobStatusStmt != nil {
		if cerr := q.updateJobStatusStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateJobStatusStmt: %w", cerr)
		}
	}
	if q.upsertSchedulerStateStmt != nil {
		if cerr := q.upsertSchedulerStateStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing upsertSchedulerStateStmt: %w", cerr)
		}
	}
	return err
}

func (q *Queries) exec(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (sql.Result, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).ExecContext(ctx, args...)
	case stmt != nil:
		return stmt.ExecContext(ctx, args...)
	default:
		return q.db.ExecContext(ctx, query, args...)
	}
}

func (q *Queries) query(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (*sql.Rows, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryContext(ctx, args...)
	default:
		return q.db.QueryContext(ctx, query, args...)
	}
}

func (q *Queries) queryRow(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) *sql.Row {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryRowContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryRowContext(ctx, args...)
	default:
		return q.db.QueryRowContext(ctx, query, args...)
	}
}

type Queries struct {
	db                          DBTX
	tx                          *sql.Tx
	acquireDistributedLockStmt  *sql.Stmt
	cleanupExpiredLocksStmt     *sql.Stmt
	cleanupOldExecutionsStmt    *sql.Stmt
	createJobStmt               *sql.Stmt
	createJobExecutionStmt      *sql.Stmt
	deleteJobStmt               *sql.Stmt
	deleteSchedulerStateStmt    *sql.Stmt
	getDistributedLockStmt      *sql.Stmt
	getJobStmt                  *sql.Stmt
	getJobByNameStmt            *sql.Stmt
	getJobExecutionStmt         *sql.Stmt
	getJobExecutionStatsStmt    *sql.Stmt
	getJobsReadyToRunStmt       *sql.Stmt
	getRunningExecutionsStmt    *sql.Stmt
	getSchedulerStateStmt       *sql.Stmt
	getSystemStatsStmt          *sql.Stmt
	listActiveJobsStmt          *sql.Stmt
	listJobExecutionsStmt       *sql.Stmt
	listJobsStmt                *sql.Stmt
	listRecentJobExecutionsStmt *sql.Stmt
	listSchedulerStatesStmt     *sql.Stmt
	releaseDistributedLockStmt  *sql.Stmt
	renewDistributedLockStmt    *sql.Stmt
	updateJobStmt               *sql.Stmt
	updateJobExecutionStmt      *sql.Stmt
	updateJobStatusStmt         *sql.Stmt
	upsertSchedulerStateStmt    *sql.Stmt
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db:                          tx,
		tx:                          tx,
		acquireDistributedLockStmt:  q.acquireDistributedLockStmt,
		cleanupExpiredLocksStmt:     q.cleanupExpiredLocksStmt,
		cleanupOldExecutionsStmt:    q.cleanupOldExecutionsStmt,
		createJobStmt:               q.createJobStmt,
		createJobExecutionStmt:      q.createJobExecutionStmt,
		deleteJobStmt:               q.deleteJobStmt,
		deleteSchedulerStateStmt:    q.deleteSchedulerStateStmt,
		getDistributedLockStmt:      q.getDistributedLockStmt,
		getJobStmt:                  q.getJobStmt,
		getJobByNameStmt:            q.getJobByNameStmt,
		getJobExecutionStmt:         q.getJobExecutionStmt,
		getJobExecutionStatsStmt:    q.getJobExecutionStatsStmt,
		getJobsReadyToRunStmt:       q.getJobsReadyToRunStmt,
		getRunningExecutionsStmt:    q.getRunningExecutionsStmt,
		getSchedulerStateStmt:       q.getSchedulerStateStmt,
		getSystemStatsStmt:          q.getSystemStatsStmt,
		listActiveJobsStmt:          q.listActiveJobsStmt,
		listJobExecutionsStmt:       q.listJobExecutionsStmt,
		listJobsStmt:                q.listJobsStmt,
		listRecentJobExecutionsStmt: q.listRecentJobExecutionsStmt,
		listSchedulerStatesStmt:     q.listSchedulerStatesStmt,
		releaseDistributedLockStmt:  q.releaseDistributedLockStmt,
		renewDistributedLockStmt:    q.renewDistributedLockStmt,
		updateJobStmt:               q.updateJobStmt,
		updateJobExecutionStmt:      q.updateJobExecutionStmt,
		updateJobStatusStmt:         q.updateJobStatusStmt,
		upsertSchedulerStateStmt:    q.upsertSchedulerStateStmt,
	}
}
