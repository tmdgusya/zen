// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repository

import (
	"context"
	"database/sql"
	"time"
)

const AcquireDistributedLock = `-- name: AcquireDistributedLock :one
INSERT INTO distributed_locks (
    lock_key,
    instance_id,
    acquired_at,
    expires_at,
    heartbeat_at
) VALUES (
    ?, ?, ?, ?, ?
) ON CONFLICT(lock_key) DO UPDATE SET
    instance_id = excluded.instance_id,
    acquired_at = excluded.acquired_at,
    expires_at = excluded.expires_at,
    heartbeat_at = excluded.heartbeat_at
WHERE expires_at < CURRENT_TIMESTAMP
RETURNING lock_key, instance_id, acquired_at, expires_at, heartbeat_at
`

type AcquireDistributedLockParams struct {
	LockKey     string    `db:"lock_key" json:"lock_key"`
	InstanceID  string    `db:"instance_id" json:"instance_id"`
	AcquiredAt  time.Time `db:"acquired_at" json:"acquired_at"`
	ExpiresAt   time.Time `db:"expires_at" json:"expires_at"`
	HeartbeatAt time.Time `db:"heartbeat_at" json:"heartbeat_at"`
}

func (q *Queries) AcquireDistributedLock(ctx context.Context, arg AcquireDistributedLockParams) (DistributedLocks, error) {
	row := q.queryRow(ctx, q.acquireDistributedLockStmt, AcquireDistributedLock,
		arg.LockKey,
		arg.InstanceID,
		arg.AcquiredAt,
		arg.ExpiresAt,
		arg.HeartbeatAt,
	)
	var i DistributedLocks
	err := row.Scan(
		&i.LockKey,
		&i.InstanceID,
		&i.AcquiredAt,
		&i.ExpiresAt,
		&i.HeartbeatAt,
	)
	return i, err
}

const CleanupExpiredLocks = `-- name: CleanupExpiredLocks :exec
DELETE FROM distributed_locks
WHERE expires_at < CURRENT_TIMESTAMP
`

func (q *Queries) CleanupExpiredLocks(ctx context.Context) error {
	_, err := q.exec(ctx, q.cleanupExpiredLocksStmt, CleanupExpiredLocks)
	return err
}

const CleanupOldExecutions = `-- name: CleanupOldExecutions :exec
DELETE FROM job_executions
WHERE started_at < ? 
  AND status IN ('success', 'failed', 'timeout')
`

func (q *Queries) CleanupOldExecutions(ctx context.Context, startedAt *time.Time) error {
	_, err := q.exec(ctx, q.cleanupOldExecutionsStmt, CleanupOldExecutions, startedAt)
	return err
}

const CreateJob = `-- name: CreateJob :one
INSERT INTO jobs (
    name,
    description,
    python_file_path,
    cron_expression,
    is_active,
    timeout_seconds,
    max_retries
) VALUES (
    ?, ?, ?, ?, ?, ?, ?
) RETURNING id, name, description, python_file_path, cron_expression, is_active, timeout_seconds, max_retries, created_at, updated_at
`

type CreateJobParams struct {
	Name           string         `db:"name" json:"name"`
	Description    sql.NullString `db:"description" json:"description"`
	PythonFilePath string         `db:"python_file_path" json:"python_file_path"`
	CronExpression string         `db:"cron_expression" json:"cron_expression"`
	IsActive       bool           `db:"is_active" json:"is_active"`
	TimeoutSeconds sql.NullInt64  `db:"timeout_seconds" json:"timeout_seconds"`
	MaxRetries     sql.NullInt64  `db:"max_retries" json:"max_retries"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (Jobs, error) {
	row := q.queryRow(ctx, q.createJobStmt, CreateJob,
		arg.Name,
		arg.Description,
		arg.PythonFilePath,
		arg.CronExpression,
		arg.IsActive,
		arg.TimeoutSeconds,
		arg.MaxRetries,
	)
	var i Jobs
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.PythonFilePath,
		&i.CronExpression,
		&i.IsActive,
		&i.TimeoutSeconds,
		&i.MaxRetries,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreateJobExecution = `-- name: CreateJobExecution :one
INSERT INTO job_executions (
    job_id,
    status,
    started_at
) VALUES (
    ?, ?, ?
) RETURNING id, job_id, status, started_at, finished_at, output, error_message, exit_code
`

type CreateJobExecutionParams struct {
	JobID     int64      `db:"job_id" json:"job_id"`
	Status    string     `db:"status" json:"status"`
	StartedAt *time.Time `db:"started_at" json:"started_at"`
}

func (q *Queries) CreateJobExecution(ctx context.Context, arg CreateJobExecutionParams) (JobExecutions, error) {
	row := q.queryRow(ctx, q.createJobExecutionStmt, CreateJobExecution, arg.JobID, arg.Status, arg.StartedAt)
	var i JobExecutions
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Status,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Output,
		&i.ErrorMessage,
		&i.ExitCode,
	)
	return i, err
}

const DeleteJob = `-- name: DeleteJob :exec
DELETE FROM jobs
WHERE id = ?
`

func (q *Queries) DeleteJob(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteJobStmt, DeleteJob, id)
	return err
}

const DeleteSchedulerState = `-- name: DeleteSchedulerState :exec
DELETE FROM scheduler_state
WHERE job_id = ?
`

func (q *Queries) DeleteSchedulerState(ctx context.Context, jobID int64) error {
	_, err := q.exec(ctx, q.deleteSchedulerStateStmt, DeleteSchedulerState, jobID)
	return err
}

const GetDistributedLock = `-- name: GetDistributedLock :one
SELECT lock_key, instance_id, acquired_at, expires_at, heartbeat_at FROM distributed_locks
WHERE lock_key = ? LIMIT 1
`

func (q *Queries) GetDistributedLock(ctx context.Context, lockKey string) (DistributedLocks, error) {
	row := q.queryRow(ctx, q.getDistributedLockStmt, GetDistributedLock, lockKey)
	var i DistributedLocks
	err := row.Scan(
		&i.LockKey,
		&i.InstanceID,
		&i.AcquiredAt,
		&i.ExpiresAt,
		&i.HeartbeatAt,
	)
	return i, err
}

const GetJob = `-- name: GetJob :one
SELECT id, name, description, python_file_path, cron_expression, is_active, timeout_seconds, max_retries, created_at, updated_at FROM jobs
WHERE id = ? LIMIT 1
`

func (q *Queries) GetJob(ctx context.Context, id int64) (Jobs, error) {
	row := q.queryRow(ctx, q.getJobStmt, GetJob, id)
	var i Jobs
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.PythonFilePath,
		&i.CronExpression,
		&i.IsActive,
		&i.TimeoutSeconds,
		&i.MaxRetries,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetJobByName = `-- name: GetJobByName :one
SELECT id, name, description, python_file_path, cron_expression, is_active, timeout_seconds, max_retries, created_at, updated_at FROM jobs
WHERE name = ? LIMIT 1
`

func (q *Queries) GetJobByName(ctx context.Context, name string) (Jobs, error) {
	row := q.queryRow(ctx, q.getJobByNameStmt, GetJobByName, name)
	var i Jobs
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.PythonFilePath,
		&i.CronExpression,
		&i.IsActive,
		&i.TimeoutSeconds,
		&i.MaxRetries,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetJobExecution = `-- name: GetJobExecution :one
SELECT id, job_id, status, started_at, finished_at, output, error_message, exit_code FROM job_executions
WHERE id = ? LIMIT 1
`

func (q *Queries) GetJobExecution(ctx context.Context, id int64) (JobExecutions, error) {
	row := q.queryRow(ctx, q.getJobExecutionStmt, GetJobExecution, id)
	var i JobExecutions
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Status,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Output,
		&i.ErrorMessage,
		&i.ExitCode,
	)
	return i, err
}

const GetJobExecutionStats = `-- name: GetJobExecutionStats :one
SELECT 
    COUNT(*) as total_executions,
    COUNT(CASE WHEN status = 'success' THEN 1 END) as success_count,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_count,
    COUNT(CASE WHEN status = 'timeout' THEN 1 END) as timeout_count,
    AVG(
        CASE 
            WHEN finished_at IS NOT NULL AND started_at IS NOT NULL 
            THEN (julianday(finished_at) - julianday(started_at)) * 86400 
        END
    ) as avg_duration_seconds
FROM job_executions
WHERE job_id = ?
`

type GetJobExecutionStatsRow struct {
	TotalExecutions    int64           `db:"total_executions" json:"total_executions"`
	SuccessCount       int64           `db:"success_count" json:"success_count"`
	FailedCount        int64           `db:"failed_count" json:"failed_count"`
	TimeoutCount       int64           `db:"timeout_count" json:"timeout_count"`
	AvgDurationSeconds sql.NullFloat64 `db:"avg_duration_seconds" json:"avg_duration_seconds"`
}

func (q *Queries) GetJobExecutionStats(ctx context.Context, jobID int64) (GetJobExecutionStatsRow, error) {
	row := q.queryRow(ctx, q.getJobExecutionStatsStmt, GetJobExecutionStats, jobID)
	var i GetJobExecutionStatsRow
	err := row.Scan(
		&i.TotalExecutions,
		&i.SuccessCount,
		&i.FailedCount,
		&i.TimeoutCount,
		&i.AvgDurationSeconds,
	)
	return i, err
}

const GetJobsReadyToRun = `-- name: GetJobsReadyToRun :many
SELECT 
    j.id, j.name, j.description, j.python_file_path, j.cron_expression, j.is_active, j.timeout_seconds, j.max_retries, j.created_at, j.updated_at,
    s.next_run
FROM jobs j
JOIN scheduler_state s ON j.id = s.job_id
WHERE j.is_active = true 
  AND s.next_run <= ?
ORDER BY s.next_run ASC
`

type GetJobsReadyToRunRow struct {
	ID             int64          `db:"id" json:"id"`
	Name           string         `db:"name" json:"name"`
	Description    sql.NullString `db:"description" json:"description"`
	PythonFilePath string         `db:"python_file_path" json:"python_file_path"`
	CronExpression string         `db:"cron_expression" json:"cron_expression"`
	IsActive       bool           `db:"is_active" json:"is_active"`
	TimeoutSeconds sql.NullInt64  `db:"timeout_seconds" json:"timeout_seconds"`
	MaxRetries     sql.NullInt64  `db:"max_retries" json:"max_retries"`
	CreatedAt      time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt      time.Time      `db:"updated_at" json:"updated_at"`
	NextRun        *time.Time     `db:"next_run" json:"next_run"`
}

func (q *Queries) GetJobsReadyToRun(ctx context.Context, nextRun *time.Time) ([]GetJobsReadyToRunRow, error) {
	rows, err := q.query(ctx, q.getJobsReadyToRunStmt, GetJobsReadyToRun, nextRun)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetJobsReadyToRunRow{}
	for rows.Next() {
		var i GetJobsReadyToRunRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.PythonFilePath,
			&i.CronExpression,
			&i.IsActive,
			&i.TimeoutSeconds,
			&i.MaxRetries,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.NextRun,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRunningExecutions = `-- name: GetRunningExecutions :many
SELECT id, job_id, status, started_at, finished_at, output, error_message, exit_code FROM job_executions
WHERE status = 'running'
ORDER BY started_at ASC
`

func (q *Queries) GetRunningExecutions(ctx context.Context) ([]JobExecutions, error) {
	rows, err := q.query(ctx, q.getRunningExecutionsStmt, GetRunningExecutions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []JobExecutions{}
	for rows.Next() {
		var i JobExecutions
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Status,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Output,
			&i.ErrorMessage,
			&i.ExitCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSchedulerState = `-- name: GetSchedulerState :one
SELECT job_id, last_run, next_run FROM scheduler_state
WHERE job_id = ? LIMIT 1
`

func (q *Queries) GetSchedulerState(ctx context.Context, jobID int64) (SchedulerState, error) {
	row := q.queryRow(ctx, q.getSchedulerStateStmt, GetSchedulerState, jobID)
	var i SchedulerState
	err := row.Scan(&i.JobID, &i.LastRun, &i.NextRun)
	return i, err
}

const GetSystemStats = `-- name: GetSystemStats :one
SELECT 
    COUNT(DISTINCT j.id) as total_jobs,
    COUNT(CASE WHEN j.is_active = true THEN 1 END) as active_jobs,
    COUNT(CASE WHEN je.status = 'running' THEN 1 END) as running_executions,
    COUNT(CASE WHEN je.started_at > ? THEN 1 END) as executions_last_24h
FROM jobs j
LEFT JOIN job_executions je ON j.id = je.job_id
`

type GetSystemStatsRow struct {
	TotalJobs         int64 `db:"total_jobs" json:"total_jobs"`
	ActiveJobs        int64 `db:"active_jobs" json:"active_jobs"`
	RunningExecutions int64 `db:"running_executions" json:"running_executions"`
	ExecutionsLast24h int64 `db:"executions_last_24h" json:"executions_last_24h"`
}

func (q *Queries) GetSystemStats(ctx context.Context, startedAt *time.Time) (GetSystemStatsRow, error) {
	row := q.queryRow(ctx, q.getSystemStatsStmt, GetSystemStats, startedAt)
	var i GetSystemStatsRow
	err := row.Scan(
		&i.TotalJobs,
		&i.ActiveJobs,
		&i.RunningExecutions,
		&i.ExecutionsLast24h,
	)
	return i, err
}

const ListActiveJobs = `-- name: ListActiveJobs :many
SELECT id, name, description, python_file_path, cron_expression, is_active, timeout_seconds, max_retries, created_at, updated_at FROM jobs
WHERE is_active = true
ORDER BY created_at DESC
`

func (q *Queries) ListActiveJobs(ctx context.Context) ([]Jobs, error) {
	rows, err := q.query(ctx, q.listActiveJobsStmt, ListActiveJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Jobs{}
	for rows.Next() {
		var i Jobs
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.PythonFilePath,
			&i.CronExpression,
			&i.IsActive,
			&i.TimeoutSeconds,
			&i.MaxRetries,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListJobExecutions = `-- name: ListJobExecutions :many
SELECT id, job_id, status, started_at, finished_at, output, error_message, exit_code FROM job_executions
WHERE job_id = ?
ORDER BY started_at DESC
LIMIT ? OFFSET ?
`

type ListJobExecutionsParams struct {
	JobID  int64 `db:"job_id" json:"job_id"`
	Limit  int64 `db:"limit" json:"limit"`
	Offset int64 `db:"offset" json:"offset"`
}

func (q *Queries) ListJobExecutions(ctx context.Context, arg ListJobExecutionsParams) ([]JobExecutions, error) {
	rows, err := q.query(ctx, q.listJobExecutionsStmt, ListJobExecutions, arg.JobID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []JobExecutions{}
	for rows.Next() {
		var i JobExecutions
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Status,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Output,
			&i.ErrorMessage,
			&i.ExitCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListJobs = `-- name: ListJobs :many
SELECT id, name, description, python_file_path, cron_expression, is_active, timeout_seconds, max_retries, created_at, updated_at FROM jobs
ORDER BY created_at DESC
`

func (q *Queries) ListJobs(ctx context.Context) ([]Jobs, error) {
	rows, err := q.query(ctx, q.listJobsStmt, ListJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Jobs{}
	for rows.Next() {
		var i Jobs
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.PythonFilePath,
			&i.CronExpression,
			&i.IsActive,
			&i.TimeoutSeconds,
			&i.MaxRetries,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListRecentJobExecutions = `-- name: ListRecentJobExecutions :many
SELECT id, job_id, status, started_at, finished_at, output, error_message, exit_code FROM job_executions
WHERE job_id = ?
ORDER BY started_at DESC
LIMIT 10
`

func (q *Queries) ListRecentJobExecutions(ctx context.Context, jobID int64) ([]JobExecutions, error) {
	rows, err := q.query(ctx, q.listRecentJobExecutionsStmt, ListRecentJobExecutions, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []JobExecutions{}
	for rows.Next() {
		var i JobExecutions
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.Status,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Output,
			&i.ErrorMessage,
			&i.ExitCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSchedulerStates = `-- name: ListSchedulerStates :many
SELECT 
    s.job_id, s.last_run, s.next_run,
    j.name as job_name,
    j.cron_expression,
    j.is_active
FROM scheduler_state s
JOIN jobs j ON s.job_id = j.id
WHERE j.is_active = true
ORDER BY s.next_run ASC
`

type ListSchedulerStatesRow struct {
	JobID          int64      `db:"job_id" json:"job_id"`
	LastRun        *time.Time `db:"last_run" json:"last_run"`
	NextRun        *time.Time `db:"next_run" json:"next_run"`
	JobName        string     `db:"job_name" json:"job_name"`
	CronExpression string     `db:"cron_expression" json:"cron_expression"`
	IsActive       bool       `db:"is_active" json:"is_active"`
}

func (q *Queries) ListSchedulerStates(ctx context.Context) ([]ListSchedulerStatesRow, error) {
	rows, err := q.query(ctx, q.listSchedulerStatesStmt, ListSchedulerStates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSchedulerStatesRow{}
	for rows.Next() {
		var i ListSchedulerStatesRow
		if err := rows.Scan(
			&i.JobID,
			&i.LastRun,
			&i.NextRun,
			&i.JobName,
			&i.CronExpression,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ReleaseDistributedLock = `-- name: ReleaseDistributedLock :exec
DELETE FROM distributed_locks
WHERE lock_key = ? AND instance_id = ?
`

type ReleaseDistributedLockParams struct {
	LockKey    string `db:"lock_key" json:"lock_key"`
	InstanceID string `db:"instance_id" json:"instance_id"`
}

func (q *Queries) ReleaseDistributedLock(ctx context.Context, arg ReleaseDistributedLockParams) error {
	_, err := q.exec(ctx, q.releaseDistributedLockStmt, ReleaseDistributedLock, arg.LockKey, arg.InstanceID)
	return err
}

const RenewDistributedLock = `-- name: RenewDistributedLock :exec
UPDATE distributed_locks
SET 
    expires_at = ?,
    heartbeat_at = ?
WHERE lock_key = ? AND instance_id = ?
`

type RenewDistributedLockParams struct {
	ExpiresAt   time.Time `db:"expires_at" json:"expires_at"`
	HeartbeatAt time.Time `db:"heartbeat_at" json:"heartbeat_at"`
	LockKey     string    `db:"lock_key" json:"lock_key"`
	InstanceID  string    `db:"instance_id" json:"instance_id"`
}

func (q *Queries) RenewDistributedLock(ctx context.Context, arg RenewDistributedLockParams) error {
	_, err := q.exec(ctx, q.renewDistributedLockStmt, RenewDistributedLock,
		arg.ExpiresAt,
		arg.HeartbeatAt,
		arg.LockKey,
		arg.InstanceID,
	)
	return err
}

const UpdateJob = `-- name: UpdateJob :one
UPDATE jobs
SET 
    name = ?,
    description = ?,
    python_file_path = ?,
    cron_expression = ?,
    is_active = ?,
    timeout_seconds = ?,
    max_retries = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, name, description, python_file_path, cron_expression, is_active, timeout_seconds, max_retries, created_at, updated_at
`

type UpdateJobParams struct {
	Name           string         `db:"name" json:"name"`
	Description    sql.NullString `db:"description" json:"description"`
	PythonFilePath string         `db:"python_file_path" json:"python_file_path"`
	CronExpression string         `db:"cron_expression" json:"cron_expression"`
	IsActive       bool           `db:"is_active" json:"is_active"`
	TimeoutSeconds sql.NullInt64  `db:"timeout_seconds" json:"timeout_seconds"`
	MaxRetries     sql.NullInt64  `db:"max_retries" json:"max_retries"`
	ID             int64          `db:"id" json:"id"`
}

func (q *Queries) UpdateJob(ctx context.Context, arg UpdateJobParams) (Jobs, error) {
	row := q.queryRow(ctx, q.updateJobStmt, UpdateJob,
		arg.Name,
		arg.Description,
		arg.PythonFilePath,
		arg.CronExpression,
		arg.IsActive,
		arg.TimeoutSeconds,
		arg.MaxRetries,
		arg.ID,
	)
	var i Jobs
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.PythonFilePath,
		&i.CronExpression,
		&i.IsActive,
		&i.TimeoutSeconds,
		&i.MaxRetries,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateJobExecution = `-- name: UpdateJobExecution :one
UPDATE job_executions
SET 
    status = ?,
    finished_at = ?,
    output = ?,
    error_message = ?,
    exit_code = ?
WHERE id = ?
RETURNING id, job_id, status, started_at, finished_at, output, error_message, exit_code
`

type UpdateJobExecutionParams struct {
	Status       string         `db:"status" json:"status"`
	FinishedAt   *time.Time     `db:"finished_at" json:"finished_at"`
	Output       sql.NullString `db:"output" json:"output"`
	ErrorMessage sql.NullString `db:"error_message" json:"error_message"`
	ExitCode     sql.NullInt64  `db:"exit_code" json:"exit_code"`
	ID           int64          `db:"id" json:"id"`
}

func (q *Queries) UpdateJobExecution(ctx context.Context, arg UpdateJobExecutionParams) (JobExecutions, error) {
	row := q.queryRow(ctx, q.updateJobExecutionStmt, UpdateJobExecution,
		arg.Status,
		arg.FinishedAt,
		arg.Output,
		arg.ErrorMessage,
		arg.ExitCode,
		arg.ID,
	)
	var i JobExecutions
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Status,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Output,
		&i.ErrorMessage,
		&i.ExitCode,
	)
	return i, err
}

const UpdateJobStatus = `-- name: UpdateJobStatus :exec
UPDATE jobs
SET 
    is_active = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateJobStatusParams struct {
	IsActive bool  `db:"is_active" json:"is_active"`
	ID       int64 `db:"id" json:"id"`
}

func (q *Queries) UpdateJobStatus(ctx context.Context, arg UpdateJobStatusParams) error {
	_, err := q.exec(ctx, q.updateJobStatusStmt, UpdateJobStatus, arg.IsActive, arg.ID)
	return err
}

const UpsertSchedulerState = `-- name: UpsertSchedulerState :exec
INSERT INTO scheduler_state (job_id, last_run, next_run)
VALUES (?, ?, ?)
ON CONFLICT(job_id) DO UPDATE SET
    last_run = excluded.last_run,
    next_run = excluded.next_run
`

type UpsertSchedulerStateParams struct {
	JobID   int64      `db:"job_id" json:"job_id"`
	LastRun *time.Time `db:"last_run" json:"last_run"`
	NextRun *time.Time `db:"next_run" json:"next_run"`
}

func (q *Queries) UpsertSchedulerState(ctx context.Context, arg UpsertSchedulerStateParams) error {
	_, err := q.exec(ctx, q.upsertSchedulerStateStmt, UpsertSchedulerState, arg.JobID, arg.LastRun, arg.NextRun)
	return err
}
